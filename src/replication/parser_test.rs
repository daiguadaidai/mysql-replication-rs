#[cfg(test)]
mod tests {
    use crate::error::ReplicationError;
    use crate::replication::parser::BinlogParse;
    use crate::replication::{
        DecodeFieldData, DecodeJson, EnumRowImageType, EventType, FormatDescriptionEvent,
        RowsEvent, TableMapEvent,
    };
    use std::io::BufReader;

    #[test]
    fn test_index_out_of_range() -> Result<(), ReplicationError> {
        let mut parser = BinlogParse::new();
        parser.format = Some(FormatDescriptionEvent {
            version: 0x4,
            server_version: vec![
                0x35, 0x2e, 0x36, 0x2e, 0x32, 0x30, 0x2d, 0x6c, 0x6f, 0x67, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0,
            ],
            create_timestamp: 0x0,
            event_header_length: 0x13,
            event_type_header_lengths: vec![
                0x38, 0xd, 0x0, 0x8, 0x0, 0x12, 0x0, 0x4, 0x4, 0x4, 0x4, 0x12, 0x0, 0x0, 0x5c, 0x0,
                0x4, 0x1a, 0x8, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x2, 0x0, 0x0, 0x0, 0xa, 0xa, 0xa,
                0x19, 0x19, 0x0, 0x12, 0x34, 0x0, 0xa, 0x28, 0x0,
            ],
            check_sum_algorithm: 0x1,
        });

        parser.tables.insert(0x3043b, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x3043b;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![0x61, 0x70, 0x70, 0x5f, 0x63, 0x72, 0x6f, 0x6e];
            tme.column_count = 0x15;
            tme.column_type = vec![
                0x3, 0xf, 0xc, 0xc, 0xf, 0x3, 0xc, 0x3, 0xfc, 0xf, 0x1, 0xfe, 0x2, 0xc, 0xf, 0xf,
                0xc, 0xf, 0xf, 0x3, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x180, 0x0, 0x0, 0x2fd, 0x0, 0x0, 0x0, 0x2, 0x180, 0x0, 0xfe78, 0x0, 0x0,
                0x180, 0x180, 0x0, 0x180, 0x180, 0x0, 0x2fd,
            ];
            tme.null_bitmap = vec![0xf8, 0xfb, 0x17];
            tme
        });
        parser.tables.insert(0x30453, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x30453;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![0x73, 0x74, 0x67, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x75, 0x70];
            tme.column_count = 0x36;
            tme.column_type = vec![
                0x3, 0x3, 0x3, 0x3, 0x3, 0xf, 0xf, 0x8, 0x3, 0x3, 0x3, 0xf, 0xf, 0x1, 0xf, 0xf,
                0xf, 0xf, 0xf, 0xf, 0xfe, 0x12, 0xf, 0xf, 0xf, 0xf6, 0x1, 0xf, 0xf, 0xf, 0xf, 0xf,
                0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xfe, 0xf6, 0x12, 0x3, 0xf, 0xf, 0x1, 0x1, 0x12, 0xf,
                0xf, 0xf, 0xf, 0x3, 0xf, 0x3,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x0, 0x2fd, 0x12c, 0x0, 0x0, 0x0, 0x0, 0x180, 0x180, 0x0, 0x30,
                0x180, 0x180, 0x180, 0x30, 0xc0, 0xfe03, 0x0, 0x180, 0x180, 0x180, 0xc02, 0x0,
                0x5a, 0x5a, 0x5a, 0x5a, 0x2fd, 0x2fd, 0x2fd, 0xc0, 0x12c, 0x30, 0xc, 0xfe06, 0xb02,
                0x0, 0x0, 0x180, 0x180, 0x0, 0x0, 0x0, 0x180, 0x180, 0x2d, 0x2fd, 0x0, 0x2fd, 0x0,
            ];
            tme.null_bitmap = vec![0xee, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x17];
            tme
        });
        parser.tables.insert(0x30504, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x30504;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![
                0x6c, 0x6f, 0x67, 0x5f, 0x73, 0x74, 0x67, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x75, 0x70,
            ];
            tme.column_count = 0x13;
            tme.column_type = vec![
                0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0xf, 0xc, 0xc, 0xc, 0xf,
                0xf, 0x3, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x180, 0x0, 0x0, 0x0, 0x180,
                0x180, 0x0, 0x2fd,
            ];
            tme.null_bitmap = vec![0x6, 0xfb, 0x5];
            tme
        });
        parser.tables.insert(0x30450, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x30450;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74];
            tme.column_count = 0x16;
            tme.column_type = vec![
                0x3, 0xfc, 0xc, 0x3, 0xc, 0xf, 0x3, 0xf, 0xc, 0xf, 0xf, 0xf, 0xf, 0x3, 0xc, 0xf,
                0xf, 0xf, 0xf, 0x3, 0x3, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x2, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x180, 0x0, 0x180, 0x180, 0x2fd, 0x2d, 0x0,
                0x0, 0x180, 0x180, 0x2fd, 0x2d, 0x0, 0x0, 0x2fd,
            ];
            tme.null_bitmap = vec![0xfe, 0xff, 0x2f];
            tme
        });
        parser.tables.insert(0x305bb, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x305bb;
            tme.flags = 0x1;
            tme.schema = vec![0x79, 0x6d, 0x63, 0x61, 0x63, 0x68, 0x67, 0x6f];
            tme.table = vec![
                0x72, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x5f, 0x6c, 0x6f, 0x67,
            ];
            tme.column_count = 0x11;
            tme.column_type = vec![
                0x3, 0x3, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xc, 0xf, 0xf, 0xc, 0xf, 0xf, 0x3, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x2fd, 0x12c, 0x2fd, 0x2fd, 0x2d, 0x12c, 0x2fd, 0x0, 0x180, 0x180, 0x0,
                0x180, 0x180, 0x0, 0x2fd,
            ];
            tme.null_bitmap = vec![0xfe, 0x7f, 0x1];
            tme
        });
        parser.tables.insert(0x16c36b, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x16c36b;
            tme.flags = 0x1;
            tme.schema = vec![0x61, 0x63, 0x70];
            tme.table = vec![
                0x73, 0x74, 0x67, 0x5f, 0x6d, 0x61, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x65,
                0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x32,
            ];
            tme.column_count = 0xe;
            tme.column_type = vec![
                0x8, 0x8, 0x3, 0x3, 0x2, 0x2, 0xf, 0x12, 0xf, 0xf, 0x12, 0xf, 0xf, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x180, 0x180, 0x0, 0x180, 0x180, 0x2fd,
            ];
            tme.null_bitmap = vec![0xba, 0x3f];
            tme
        });
        parser.tables.insert(0x16c368, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x16c368;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![
                0x73, 0x74, 0x67, 0x5f, 0x6d, 0x61, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x65,
                0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x32,
            ];
            tme.column_count = 0xe;
            tme.column_type = vec![
                0x8, 0x8, 0x3, 0x3, 0x2, 0x2, 0xf, 0x12, 0xf, 0xf, 0x12, 0xf, 0xf, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x180, 0x180, 0x0, 0x180, 0x180, 0x2fd,
            ];
            tme.null_bitmap = vec![0xba, 0x3f];
            tme
        });
        parser.tables.insert(0x3045a, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x3045a;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![0x63, 0x6f, 0x6e, 0x73];
            tme.column_count = 0x1e;
            tme.column_type = vec![
                0x3, 0x3, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xfe, 0x12, 0xf, 0xf, 0xf, 0xf6, 0xf, 0xf,
                0xf, 0xf, 0x1, 0x1, 0x1, 0x12, 0xf, 0xf, 0x12, 0xf, 0xf, 0x3, 0xf, 0x1,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x30, 0x180, 0x180, 0x180, 0x30, 0xc0, 0xfe03, 0x0, 0x180, 0x180, 0x180,
                0xc02, 0x180, 0x180, 0x180, 0x180, 0x0, 0x0, 0x0, 0x0, 0x180, 0x180, 0x0, 0x180,
                0x180, 0x0, 0x2fd, 0x0,
            ];
            tme.null_bitmap = vec![0xfc, 0xff, 0xe3, 0x37];
            tme
        });
        parser.tables.insert(0x3045f, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x3045f;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![0x63, 0x6f, 0x6e, 0x73, 0x5f, 0x61, 0x64, 0x64, 0x72];
            tme.column_count = 0x19;
            tme.column_type = vec![
                0x3, 0x3, 0x3, 0x1, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xfe, 0x3, 0xc, 0x1, 0xc,
                0xf, 0xf, 0xc, 0xf, 0xf, 0x3, 0xf, 0x4, 0x4,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x2fd, 0x2fd, 0x2fd, 0xc0, 0x12c, 0x30, 0xc, 0xfe06, 0x0, 0x0,
                0x0, 0x0, 0x180, 0x180, 0x0, 0x180, 0x180, 0x0, 0x2fd, 0x4, 0x4,
            ];
            tme.null_bitmap = vec![0xf0, 0xef, 0x5f, 0x0];
            tme
        });
        parser.tables.insert(0x3065f, {
            let mut tme = TableMapEvent::default();
            tme.table_id_size = 6;
            tme.table_id = 0x3065f;
            tme.flags = 0x1;
            tme.schema = vec![0x73, 0x65, 0x69, 0x75, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72];
            tme.table = vec![
                0x63, 0x6f, 0x6e, 0x73, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x70,
                0x65, 0x61, 0x6b, 0x6f, 0x75, 0x74, 0x5f, 0x6c, 0x65, 0x74, 0x74, 0x65, 0x72,
            ];
            tme.column_count = 0xd;
            tme.column_type = vec![
                0x3, 0x3, 0x3, 0x3, 0x1, 0x12, 0xf, 0xf, 0x12, 0xf, 0xf, 0x3, 0xf,
            ];
            tme.column_meta = vec![
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x180, 0x180, 0x0, 0x180, 0x180, 0x0, 0x2fd,
            ];
            tme.null_bitmap = vec![0xe0, 0x17];
            tme
        });

        let data = vec![
            /* 0x00, */ 0xc1_u8, 0x86, 0x8e, 0x55, 0x1e, 0xa5, 0x14, 0x80, 0xa, 0x55, 0x0,
            0x0, 0x0, 0x7, 0xc, 0xbf, 0xe, 0x0, 0x0, 0x5f, 0x6, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x2,
            0x0, 0xd, 0xff, 0x0, 0x0, 0x19, 0x63, 0x7, 0x0, 0xca, 0x61, 0x5, 0x0, 0x5e, 0xf7, 0xc,
            0x0, 0xf5, 0x7, 0x0, 0x0, 0x1, 0x99, 0x96, 0x76, 0x74, 0xdd, 0x10, 0x0, 0x73, 0x69,
            0x67, 0x6e, 0x75, 0x70, 0x5f, 0x64, 0x62, 0x5f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
            0x6, 0x0, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0xb1, 0x3c, 0x38, 0xcb,
        ];

        let _ = parser.parse(&data)?;

        Ok(())
    }

    #[test]
    fn test_parse_event() -> Result<(), ReplicationError> {
        let mut parser = BinlogParse::new();
        parser.format = Some(FormatDescriptionEvent {
            version: 0x4,
            server_version: vec![
                0x35, 0x2e, 0x36, 0x2e, 0x32, 0x30, 0x2d, 0x6c, 0x6f, 0x67, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0,
            ],
            create_timestamp: 0x0,
            event_header_length: 0x13,
            event_type_header_lengths: vec![
                0x38, 0xd, 0x0, 0x8, 0x0, 0x12, 0x0, 0x4, 0x4, 0x4, 0x4, 0x12, 0x0, 0x0, 0x5c, 0x0,
                0x4, 0x1a, 0x8, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x2, 0x0, 0x0, 0x0, 0xa, 0xa, 0xa,
                0x19, 0x19, 0x0, 0x12, 0x34, 0x0, 0xa, 0x28, 0x0,
            ],
            check_sum_algorithm: 0x0,
        });

        struct Case {
            pub byte_data: Vec<u8>,
            pub event_size: u32,
        }
        let test_cases = vec![
            Case {
                byte_data: vec![
                    0x86, 0x4c, 0x9c, 0x5d, 0x03, 0x65, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
                    0x4d, 0x01, 0x00, 0x00, 0x00, 0x00,
                ],
                event_size: 19,
            },
            Case {
                byte_data: vec![
                    0x15, 0x50, 0x9c, 0x5d, 0x03, 0x65, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
                    0x59, 0x01, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x82, 0xa8, 0x50,
                ],
                event_size: 23,
            },
        ];

        for tc in &test_cases {
            let mut r = BufReader::new(&*tc.byte_data);
            parser.parse_single_event(&mut r, &|e| {
                assert_eq!(EventType::StopEvent, e.header.as_ref().unwrap().event_type);
                assert_eq!(tc.event_size, e.header.as_ref().unwrap().event_size);

                Ok(())
            })?;

            let e = parser.parse(&tc.byte_data)?;
            assert_eq!(EventType::StopEvent, e.header.as_ref().unwrap().event_type);
            assert_eq!(tc.event_size, e.header.as_ref().unwrap().event_size);
        }

        Ok(())
    }

    #[test]
    fn test_rows_event_decode_func() -> Result<(), ReplicationError> {
        struct Case {
            pub byte_data: Vec<u8>,
            pub event_size: u32,
            pub event_type: EventType,
        }
        let test_cases = vec![
            // FORMAT_DESCRIPTION_EVENT
            Case {
                byte_data: vec![
                    0x64, 0x61, 0x72, 0x63, 0xf, 0xb, 0x0, 0x0, 0x0, 0x77, 0x0, 0x0, 0x0, 0x7b,
                    0x0, 0x0, 0x0, 0x1, 0x0, 0x4, 0x0, 0x35, 0x2e, 0x37, 0x2e, 0x32, 0x32, 0x2d,
                    0x6c, 0x6f, 0x67, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x61, 0x72,
                    0x63, 0x13, 0x38, 0xd, 0x0, 0x8, 0x0, 0x12, 0x0, 0x4, 0x4, 0x4, 0x4, 0x12, 0x0,
                    0x0, 0x5f, 0x0, 0x4, 0x1a, 0x8, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x2, 0x0, 0x0,
                    0x0, 0xa, 0xa, 0xa, 0x2a, 0x2a, 0x0, 0x12, 0x34, 0x0, 0x1, 0xb8, 0x78, 0x9d,
                    0xfe,
                ],
                event_size: 119,
                event_type: EventType::FormatDescriptionEvent,
            },
            // TABLE MAP EVENT tb(INT)
            Case {
                byte_data: vec![
                    0x8d, 0x61, 0x72, 0x63, 0x13, 0xb, 0x0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x0, 0xa7,
                    0x0, 0x0, 0x0, 0x1, 0x0, 0x6c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x64,
                    0x62, 0x0, 0x3, 0x74, 0x62, 0x6c, 0x0, 0x1, 0x3, 0x0, 0x0, 0x63, 0x17, 0xe6,
                    0xf0,
                ],
                event_size: 44,
                event_type: EventType::TableMapEvent,
            },
            // rows INT(1)
            Case {
                byte_data: vec![
                    0xb6, 0x61, 0x72, 0x63, 0x1e, 0xb, 0x0, 0x0, 0x0, 0x28, 0x0, 0x0, 0x0, 0xcf,
                    0x0, 0x0, 0x0, 0x1, 0x0, 0x6c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x0,
                    0x1, 0xff, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf9, 0xf7, 0x89, 0x2a,
                ],
                event_size: 40,
                event_type: EventType::WriteRowsEventv2,
            },
            // TABLE MAP EVENT tb(TINY)
            Case {
                byte_data: vec![
                    0x22, 0x6c, 0x72, 0x63, 0x13, 0xb, 0x0, 0x0, 0x0, 0x2e, 0x0, 0x0, 0x0, 0xfd,
                    0x0, 0x0, 0x0, 0x1, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x3, 0x64,
                    0x62, 0x31, 0x0, 0x4, 0x74, 0x62, 0x6c, 0x31, 0x0, 0x1, 0x1, 0x0, 0x0, 0x32,
                    0xec, 0x2f, 0x4,
                ],
                event_size: 46,
                event_type: EventType::TableMapEvent,
            },
            // rows LONG(1)
            // panic if not set rows event decode func
            Case {
                byte_data: vec![
                    0xeb, 0x64, 0x72, 0x63, 0x1e, 0xb, 0x0, 0x0, 0x0, 0x2d, 0x0, 0x0, 0x0, 0x2a,
                    0x1, 0x0, 0x0, 0x1, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x2, 0x0,
                    0x1, 0xff, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6e, 0xef, 0xb2,
                    0xb1,
                ],
                event_size: 45,
                event_type: EventType::WriteRowsEventv2,
            },
        ];

        let mut parser = BinlogParse::new();
        parser.set_rows_event_decode_func(Some(Box::new(|re, bs| {
            let _ = re.decode_header(bs)?;

            Ok(())
        })));

        for tc in &test_cases {
            let e = parser.parse(&tc.byte_data)?;
            assert_eq!(tc.event_type, e.header.as_ref().unwrap().event_type);
            assert_eq!(tc.event_size, e.header.as_ref().unwrap().event_size);
        }

        Ok(())
    }

    #[test]
    fn test_rows_event_decode_image_with_empty_json() -> Result<(), ReplicationError> {
        let data = vec![
            1_u8, 7, 0, 246, 43, 15, 0, 235, 175, 80, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 153,
            172, 250, 190, 195, 153, 175, 171, 49, 24, 52, 17, 0, 0,
        ];

        let bitmap = vec![255_u8];
        let mut table = TableMapEvent::default();
        table.column_type = vec![3, 3, 245, 245, 245, 18, 18, 3];
        table.column_meta = vec![0, 0, 4, 4, 4, 0, 0, 0];

        let mut e = RowsEvent::default();
        e.event_type = EventType::PartialUpdateRowsEvent;
        e.table = table.clone();
        e.column_count = table.column_type.len() as u64;
        let n = e.decode_image(&data, &bitmap, EnumRowImageType::UpdateAI)?;
        assert_eq!(data.len(), n as usize);

        assert_eq!(e.rows.len(), 1);
        assert_eq!(e.rows[0].len(), table.column_type.len());

        let row = &e.rows[0];
        assert_eq!(DecodeFieldData::Isize(994294), row[0]);
        assert_eq!(DecodeFieldData::Isize(38842347), row[1]);
        assert_eq!(DecodeFieldData::Json(DecodeJson::Bytes(vec![])), row[2]); // empty json
        assert_eq!(DecodeFieldData::Json(DecodeJson::Bytes(vec![])), row[3]); // empty json
        assert_eq!(DecodeFieldData::Json(DecodeJson::Bytes(vec![])), row[4]); // empty json
        assert_eq!(DecodeFieldData::Isize(4404), row[7]);

        Ok(())
    }
}
